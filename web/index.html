<html>
<head>

  <!-- Useful URLS:

  To stack fontawesome glyphs.
  https://fontawesome.com/docs/web/style/stack

  Overlay elements on leaflet.
  https://jsfiddle.net/falkedesign/2dbfyw0z/
  -->

  <!-- Boostrap -->
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
        integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN"
        crossorigin="anonymous">
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"
          integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL"
          crossorigin="anonymous"></script>

  <!-- Leaflet (ensure leaflet.js is loaded after leaflet.css -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
          integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
          crossorigin=""></script>

  <!-- Leaflet plugins -->
  <script type="text/javascript"
          src="https://cdn.jsdelivr.net/npm/leaflet.icon.glyph@0.3.0/Leaflet.Icon.Glyph.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/beautifymarker@1.0.9/leaflet-beautify-marker-icon.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/beautifymarker@1.0.9/leaflet-beautify-marker-icon.min.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-locatecontrol/0.85.1/L.Control.Locate.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet-locatecontrol/0.85.1/L.Control.Locate.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/leaflet.markercluster.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/MarkerCluster.Default.min.css">

  <!-- Font awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">

  <!-- Jquery -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <script src="https://unpkg.com/@testing-library/dom/dist/dom-testing-library.umd.js"></script>
    <script src="https://unpkg.com/@testing-library/user-event@14.0.0/dist/user-event.umd.js"></script>

  <!-- Instagram embed -->
  <script async src="https://www.instagram.com/embed.js"></script>

  <!-- Own -->
  <!--<script src="./data-bard.js"></script>-->
  <script src="./data.js"></script>
  <script src="./settings.js"></script>
  <script src="./export.js"></script>
  <link rel="stylesheet" href="./style.css">

  <style>

    #map {
      height: 100%;
    }

    .offcanvas-btn {
      top: 50%;
      visibility: visible;
      height: 50px;
      /*color: #c00000;
      text-shadow: 0 0 10px blue;*/
    }

    #trigger-offcanvas-right {
      left: -33px;
      border-top-right-radius: 0rem;
      border-bottom-right-radius: 0rem;
    }

    #trigger-offcanvas-left {
      left: 399px;
      border-bottom-left-radius: 0rem;
      border-top-left-radius: 0rem;
    }
  </style>
</head>
<body>

<!-- The leaflet map -->
<div id="map" class="z-1"></div>

<!-- The left offcanvas -->
<div class="offcanvas offcanvas-start"
     tabindex="-1"
     id="offcanvasLeft"
     data-overlay="false"
     aria-labelledby="offcanvasLeftLabel"
     data-bs-scroll="true"
     data-bs-backdrop="true">

  <button id='trigger-offcanvas-left'
          class="btn btn-light btn-outline-secondary offcanvas-btn position-absolute border-start-0 z-3 mt-2"
          type="button"
          data-bs-toggle="offcanvas"
          data-bs-target="#offcanvasLeft"
          aria-controls="offcanvasLeft">
    <!--<i class="bi bi-list"></i>-->
    <i class="fas fa-caret-right"></i>
  </button>

  <!--
  <div class="offcanvas-header">
      <h5 id='post-shortcode'></h5>
      <button type="button"
         class="btn-close text-reset"
         data-bs-dismiss="offcanvas"
         aria-label="Close">
      </button>
  </div>
  -->
  <div id='offcanvas-left-body' class="offcanvas-body">


    <div class="mb-3">
      <label for="formFile" class="form-label"></label>
      <input class="form-control" type="file" id="formFile" disabled>
      <div id="fileHelp" class="form-text">
        (File upload functionality coming soon)
      </div>
    </div>

    <div class="mb-3">
      <button id="export-kml-button" class="btn-google w-100">
          <span class="google-icon-wrapper">
              <i class="fa-brands fa-google"></i>
          </span>
          <span>Export to Google Maps</span>
      </button>
    </div>

    <!--
    <div id="info"></div>

    <div class="mb-3"> Mapping</div>
    <div class="input-group mb-1 input-group-sm">
      <span class="input-group-text w-25" id="basic-addon1"> Title </span>
      <input type="text" class="form-control" placeholder="Username"
             ria-label="Username" aria-describedby="basic-addon1">
    </div>

    <div class="input-group mb-1 input-group-sm">
      <span class="input-group-text w-25" id="title"> Title  </span>
      <select class="form-select form-select-sm" aria-label="Small select example">
        <option selected>Select one value...</option>
        <option value="1">One</option>
        <option value="2">Two</option>
        <option value="3">Three</option>
      </select>
    </div>
    -->

    <!--<hr>-->


     <!-- -------------------------------------------------------- -->
     <!-- Configuring the clustering settings                      -->
     <!-- -------------------------------------------------------- -->
     <div class="p-2 bg-light border rounded">
        <label for="cluster-radius-slider" class="form-label d-flex justify-content-between">
            Cluster Aggressiveness
            <span class="badge bg-secondary" id="cluster-radius-value">80</span>
        </label>
        <div class="d-flex align-items-center">
            <span class="small me-2">Less</span>
            <input type="range" class="form-range"
                   min="20"
                   max="120"
                   step="10"
                   value="80"
                   id="cluster-radius-slider">
            <span class="small ms-2">More</span>
        </div>
    </div>

    <div class="mb-3"></div>

    <!-- -------------------------------------------------------- -->
    <!-- Legend & filtering of markers by type                    -->
    <!-- -------------------------------------------------------- -->
    <div class="dropdown" id="legend-widget-container">

      <button class="btn btn-light border dropdown-toggle w-100" type="button"
              id="legend-dropdown-button" data-bs-toggle="dropdown"
              data-bs-auto-close="outside" aria-expanded="false">
          <i class="fa-solid fa-list me-1"></i>
          Map Legend
      </button>

        <div class="dropdown-menu p-2" aria-labelledby="legend-dropdown-button">
            <li>
                <input type="text" class="form-control" id="legend-search-input"
                       placeholder="Search legend...">
            </li>
            <li><hr class="dropdown-divider"></li>
            <li class="list-group-item border-0 py-1 px-2 small">
              <div class="d-flex align-items-center">
                  <input class="form-check-input me-2" type="checkbox" id="legend-select-all" checked>
                  <span class="fa-stack fa-1x me-2" style="visibility: hidden;" aria-hidden="true"></span>
                  <label class="form-check-label" for="legend-select-all">
                      <strong>Select / Deselect All</strong>
                  </label>
              </div>
          </li>

            <ul class="list-group list-group-flush" id="legend-list-items">
                </ul>
        </div>
    </div>
    <div id="legend-markers"></div>





    <!-- <button class="btn btn-secondary"> Save </button> -->

    <!--
    <div class="row g-3 pb-1">
      <div class="">
        <div class="form-check form-switch">
          <input class="form-check-input" type="checkbox" role="switch" id="flexSwitchCheckChecked" checked>
          <label class="form-check-label" for="flexSwitchCheckChecked">Checked switch checkbox input</label>
        </div>
      </div>


      <div class="d-flex">
        <div class="flex-fill">
          <input type="text" class="form-control form-control-sm"
                 placeholder="Historic" aria-label="Historic"
                 disabled>
        </div>
        <div class="ps-1">
          <input type="color" id="unicolor"
                 class="form-control form-control-color form-control-sm"
                 name="head" value="#B0E9D5">
        </div>
      </div>
    </div>

    <div class="row g-3 pb-1">
      <div class="d-flex">
        <div class="flex-fill rounded-start">
          <span class="form-control form-control-sm rounded rounded-start"> Nature </span>
        </div>
        <div class="ps-1">
          <input type="color" id="unicolor"
                 class="form-control form-control-color form-control-sm rounded-end"
                 name="head" value="#B0E9D5">
        </div>
      </div>
    </div>
    -->

    <hr>


  </div>
</div>


<!-- The right offcanvas -->
<div class="offcanvas offcanvas-end show"
     tabindex="-1"
     id="offcanvasRight"
     data-overlay="false"
     aria-labelledby="offcanvasRightLabel"
     data-bs-scroll="true"
     data-bs-backdrop="false">

  <button id='trigger-offcanvas-right'
          class="btn btn-light btn-outline-secondary offcanvas-btn position-absolute border-end-0 z-3 mt-2"
          type="button"
          data-bs-toggle="offcanvas"
          data-bs-target="#offcanvasRight"
          aria-controls="offcanvasRight">
    <!--<i class="bi bi-list"></i>-->
    <i class="fas fa-caret-left"></i>
  </button>

  <!--
  <div class="offcanvas-header">
      <h5 id='post-shortcode'></h5>
      <button type="button"
         class="btn-close text-reset"
         data-bs-dismiss="offcanvas"
         aria-label="Close">
      </button>
  </div>
  -->
  <div id='offcanvas-body' class="offcanvas-body">
    <div id='post-embed'>
      <div class="alert alert-info" role="alert">
        Tap or click a map marker to view the details!
      </div>
    </div>
  </div>
</div>

<!--
<div class="p-2 bg-light text-dark rounded metric-pill shadow-sm"
     style="position:fixed; bottom:60px; left:20px;
        z-index:999; font-size: 0.75rem; width:130px;">
  <span class="text-muted text-left small me-2 text-uppercase">Posts</span>
  <span id="nposts" class="text-right fw-bolder h5 text-dark mb-0"></span>
</div>
<div class="p-2 bg-light text-dark rounded shadow-sm"
     style="position:fixed; bottom:10px; left:20px;
      z-index:999; font-size: 0.75rem; width: 130px;">
  <span class="text-muted text-left small me-2 text-uppercase">Markers</span>
  <span id="nmarkers" class="text-right fw-bolder h5 text-dark mb-0"></span>
</div>
-->


<div class="p-2 bg-light text-dark rounded shadow-sm text-center"
     style="position:fixed; bottom:10px; left:80px; transform:translateX(-50%);
        z-index:999; font-size: 0.75rem; width:100px;">
  <span class="text-muted small me-2 text-uppercase">Posts</span>
  <span id="nposts" class="text-muted fw-bolder"></span>
</div>
<div class="p-2 bg-light text-dark rounded shadow-sm text-center"
     style="position:fixed; bottom:10px; left:195px; transform:translateX(-50%);
      z-index:999; font-size: 0.75rem; width: 120px;">
  <span class="text-muted text-left small me-2 text-uppercase">Markers</span>
  <span id="nmarkers" class="text-muted fw-bolder"></span>
</div>

</body>
<script>

    ATTRDICT = {
        FLAIR: {
            title: 'text',
            shortcode: 'shortcode',
            subtitle: 'display_name',
            type: 'type',
            latitude: 'lat',
            longitude: 'lon'
        },
        BARD: {
            title: 'name',
            shortcode: 'shortcode',
            subtitle: 'display_name',
            latitude: 'lat',
            longitude: 'lon',
            type: 'type'
        },
        TMP: {
            title: 'geo_name',
            shortcode: 'ent_shortcode',
            subtitle: 'geo_display_name',
            latitude: 'geo_lat',
            longitude: 'geo_lon',
            type: 'geo_type',
            caption: 'ent_text',
            confidence: 'ent_confidence',
            'class': 'geo_class',
            rank: 'geo_place_rank'
        },
        GMN : {
            title: 'title',
            subtitle: 'subtitle',
            latitude: 'lat',
            longitude: 'lon',
            shortcode: 'shortcode',
            type: 'type',
            'class': 'class',
            confidence: 'confidence',
            rank: 'rank'

        }
    }

    ATTR = ATTRDICT.GMN

    function get(obj, attr, mapping) {
        return obj[mapping[attr]]
    }

    function get(obj, attr, mapping) {
      // Check if `attr` is in `mapping` AND the resulting key is in `obj`
      return (attr in mapping && mapping[attr] in obj) ? obj[mapping[attr]] : '';
    }

    function get(obj, attr, mapping) {
      const targetKey = mapping?.[attr];

      // Check if targetKey is truthy AND if that key exists in obj
      if (targetKey && targetKey in obj) {
        return obj[targetKey];
      }
      return '';
    }


    // -------------------------------------
    // Helper functions
    // -------------------------------------
    String.prototype.format = function () {
        // store arguments in an array
        var args = arguments;
        // use replace to iterate over the string
        // select the match and check if related argument is present
        // if yes, replace the match with the argument
        return this.replace(/{([0-9]+)}/g, function (match, index) {
            // check if the argument is present
            return typeof args[index] == 'undefined' ? match : args[index];
        });
    };

    String.prototype.title = function () {
        return this.replace(/(?:^|\s)\w/g, function (match) {
            return match.toUpperCase();
        });
    }

    function objectToString(obj, fmt) {
        let result = '';
        for (let key in obj) {
            if (obj.hasOwnProperty(key)) {
                result += fmt.format(key, obj[key]);
            }
        }
        return result;
    }

    function isFloat(n){
      return Number(n) === n && n % 1 !== 0;
    }

    // -------------------------------------
    // Templates
    // -------------------------------------
    /* Align title left and value right.
      <div class="d-flex justify-content-between">
        <span class="fw-bold">Class:</span>
        <span class="text-nowrap">{7}</span>
      </div>
     */

    /* .. note: Could this be done in a better way using some kind of
                templates from either HTML or external libraries such
                as jQuery?
     */


    var template_embed = `
     <blockquote class="instagram-media"
         data-instgrm-captioned
         data-instgrm-permalink="https://www.instagram.com/p/{0}/?utm_source=ig_embed&amp;utm_campaign=loading"
         data-instgrm-version="14" style="width:100%;">
     </blockquote>
  `

    var template_popup = `

    <div class="card mb-3 w" style="max-width: 540px;">
      <div class="row no-gutters">
        <!--
        <div class="col-md-4">
          <img src="..." class="card-img" alt="...">
        </div>
        -->
        <div class="col-md-12">
          <div class="card-body position-relative">

            <a class="text-right position-absolute top-0 end-0 p-2"
               href="https://www.google.com/maps/place/{0}/@{5},{6},17z/"
               target="_blank">
               <img src="https://www.google.com/images/branding/product/ico/maps15_bnuw3a_32dp.ico" height="22">
            </a>

            <h5 class="card-title lh-sm mb-0">{0}</h5>
            <a href="https://www.instagram.com/p/{1}/?img_index=1"
               class="small text-decoration-none"
               target="_blank">{1}
             </a>

            <p class="card-text">{2}</p>
            <!--<p class="card-text"><small class="text-muted">Last updated 3 mins ago</small></p>-->
            <div class="small text-body text-opacity-50">
             Caption: {3} <br>
             Confidence: {4} <br>
             Location: ({5}, {6})
              <a href="https://www.google.com/maps/place/{5},{6}"
                 class="small text-decoration-none"
                 target="_blank"><i class="bi bi-geo-fill"></i>
               </a><br>
             Class: {7} <br>
             Type: {8} <br>
             Rank: {9} <br>

            <a class="float-end"
               data-bs-toggle="collapse"
               data-bs-target="#collapseExample"
               role="button"
               aria-expanded="false"
               aria-controls="collapseExample">
              See more
            </a><br>

             <div class="collapse" id="collapseExample"> <hr> {10} </div>

            </div>
          </div>
        </div>
      </div>
    </div>
  `

    function getPopupHTML(post, entry) {
        /**
         * Get the popup HTML content.
         * \*entry.confidence.toFixed(3) || undefined,
         */

        return template_popup.format(
            get(entry, 'title', ATTR), //.title(),
            get(post, 'shortcode', ATTR),
            get(entry, 'subtitle', ATTR),
            get(entry, 'caption', ATTR),
            get(entry, 'confidence', ATTR),
            get(entry, 'latitude', ATTR).toFixed(3),
            get(entry, 'longitude', ATTR).toFixed(3),
            get(entry, 'class', ATTR),
            get(entry, 'type', ATTR),
            get(entry, 'rank', ATTR),

            //entry.text,
            //'--',
            //entry.lat.toFixed(3),
            //entry.lon.toFixed(3),
            //entry.class,
            //entry.type,
            //entry.place_rank,
            objectToString(entry, '{0}: {1}<br>')
        )
    }

    // -----------------------------
    // Customizing markers
    // -----------------------------
    // Div marker with fontawesome
    const fontAwesomeIcon = L.divIcon({
        html: '<i class="fa fa-map-marker fa-4x"></i>',
        iconSize: [20, 20],
        className: 'myDivIcon'
    });

    const houseIcon = L.divIcon({
        html: '<div style="background-color:#c30b82;" class="marker-pin"><i class="bi bi-house"></i></div>',
        iconSize: [20, 20],
        className: 'leaflet-marker-icon'
    });

    // Div marker with own css
    const pin = L.divIcon({
        html: '<div class="pin1"></div>',
        iconSize: [20, 20],
        className: 'leaflet-marker-icon'
    });

    // Using an external library.
    var glyph = L.icon.glyph({
        prefix: 'fas', glyph: 'globe', // glyphColor: 'brown'
    });


    function get_beautify_icon(entry) {
        /**
         * Creates the arguments for beautify
         *
         * Ref: https://github.com/masajid390/BeautifyMarker
         **/

        // Merge information giving priority to <type>.
        d = {
            ...MARKER_STYLE[get(entry, 'class', ATTR)],
            ...MARKER_STYLE[get(entry, 'type', ATTR)]
        }

        // Set missing values
        d.backgroundColor = d.backgroundColor || 'blue'
        d.borderColor = LightenDarkenColor(d.backgroundColor, -80)
        d.textColor = d.textColor || 'white'

        // Return icon
        return L.BeautifyIcon.icon({
            icon: d.icon || '',
            //iconSize: L.point(22, 22), // circle: (22, 22), marker (28, 28)
            //iconShape: 'circle', // marker, circle
            //iconAnchor: L.point(11, 6),  // 11,6
            //innerIconAnchor: L.point(0, 4), // 0,3
            iconShape: 'marker',
            borderWidth: 1,
            borderStyle: 'solid',
            borderColor: d.borderColor,
            backgroundColor: d.backgroundColor,
            textColor: d.textColor,
            spin: false
        })
    }

    function get_icon(i, d) {
        /**
         * This class choses the type of icon to use
         **/
        if (i == 1)
            return fontAwesomeIcon
        else if (i == 2)
            return houseIcon
        else if (i == 3)
            return pin
        else if (i == 4)
            return glyph
        else if (i == 5)
            return get_beautify_icon(d)
        else
            return {}
    }


    // ------------------------------------------------------------------
    // Main
    // ------------------------------------------------------------------
    // Constants
    const attribution_osm = '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    const attribution_gmp = '&copy; <a href="http://www.googlemaps.com/copyright">GoogleMaps</a>'
    const geo_ldn = [51.505, -0.09]      // Center map in London
    const geo_mdr = [40.4168, -3.7038]   // Center map in Madrid

    // ------------------------------------------------------------------
    // Map Initialization
    // ------------------------------------------------------------------
    // Create variables
    let map;
    //let markerClusterGroup;
    let allMarkers = [];

    // Create map
    map = L.map('map', {
      preferCanvas: true
    }).setView(geo_mdr, 6);

    // Add tile layer (need to give attribution)
    L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: attribution_osm
    }).addTo(map);

    // Add current location button.
    L.control.locate({
      strings: {
        title: "Show my location"
      }
    }).addTo(map);

    // -- Define global variables --
    let markers = L.markerClusterGroup({
      maxClusterRadius: 50,
      disableClusteringAtZoom: 13
    })


    // -----------------------------------------------------------------
    // Geolocation Functions
    // ------------------------------------------------------------------
    // Get the user's current location
    navigator.geolocation.getCurrentPosition(onSuccess, onError);

    // Success callback function
    function onSuccess(position) {
        const lat = position.coords.latitude;  // latitude
        const lon = position.coords.longitude; // longitude
        const zoomLevel = 13;                  // zoom
        // Center the map on the user's location
        map.setView([lat, lon], zoomLevel);
        // Add a marker at the user's location
        L.marker([lat, lon])
            .addTo(map)
            .bindPopup("You are here!")
            .openPopup();
    }

    // Error callback function
    function onError(err) {
        console.warn(`ERROR(${err.code}): ${err.message}`);
    }

    // -----------------------------------------------------------------
    // Brief hello world example
    // -----------------------------------------------------------------
    /*
    // Add a marker and open it.
    var marker = L.marker([51.5, -0.09]).addTo(map);
    marker.bindPopup("<b>Hello world!</b><br>I am a popup.").openPopup();
    var popup = L.popup()
      .setLatLng([51.513, -0.09])
      .setContent("I am a standalone popup.")
      .openOn(map);

    // Show latitude and longitude on click.
    var popup = L.popup();
    function onMapClick(e) {
        popup
            .setLatLng(e.latlng)
            .setContent("You clicked the map at " + e.latlng.toString())
            .openOn(map);
    }
    map.on('click', onMapClick);
    */




    // -----------------------------------------------------------------
    // Legend & Info Functions
    // ------------------------------------------------------------------
    var template_legend = `
        <div class="input-group mb-1 input-group-sm d-flex">
          <div class="input-group-text flex-0">
            <input class="form-check-input mt-0" type="checkbox" value="" aria-label="" checked>
          </div>
          <input type="text" class="form-control form-control-sm w-75"
                 aria-label="Text input with checkbox" placeholder="{0}">
          <input type="color" id="unicolor"
             class="form-control form-control-color form-control-sm"
             name="head" value="{1}">
        </div>`

    function populateLegend(marker) {
      // Group by type
      const result = Object.groupBy(data, ({ type }) => type);

      // Display legend
      Object.entries(result).forEach(([key, value]) => {
        var d = MARKER_STYLE[key] || {}
        var c = d.backgroundColor || '#D3D3D3'
        var tmp = template_legend.format(key,  c)
        $('#legend-markers').append(tmp)
      });
    }

    function getShortcodeCount(data) {
       return new Set(data.map(item => item.post_shortcode)).size;
    }

    function getMarkersCount(data) {
      return data.reduce((accumulator, currentValue) => {
        const locationsArray = currentValue.gemini_locations;
        const locationCount = Array.isArray(locationsArray) ? locationsArray.length : 0;
        return accumulator + locationCount;
      }, 0);
    }

  /*
    ================================================================
    CORE LEGEND LOGIC (from previous step)
    ================================================================
    */

    /**
     * Groups all entries in MARKER_STYLE by their icon/color combination.
     * @returns {Array} An array of grouped style objects.
     */
    function getGroupedStyles() {
        const styleGroups = {};
        Object.entries(MARKER_STYLE).forEach(([type, style]) => {
            const color = style.backgroundColor || '#D3D3D3';
            const icon = style.icon || 'location-dot';
            const key = `${icon}-${color}`;

            if (!styleGroups[key]) {
                styleGroups[key] = {
                    icon: icon,
                    color: color,
                    types: [type]
                };
            } else {
                styleGroups[key].types.push(type);
            }
        });
        return Object.values(styleGroups);
    }

    /**
     * Counts all markers in the global list by their type.
     * @param {Array<L.Marker>} markers - The global 'allMarkers' array.
     * @returns {object} An object (map) like { camera: 5, construction: 2, ... }
     */
    function countMarkersByType(markers) {
        const counts = {};
        markers.forEach(marker => {
            //console.log(marker)
            // Get the type stored in the marker's options
            const type = marker.options.location.type;
            if (type) {
                // Add to the count for that type, or initialize it to 1
                counts[type] = (counts[type] || 0) + 1;
            }
        });
        return counts;
    }

    /*
    ================================================================
    Create filterable Legend
    ================================================================
    */

    /**
     * Generates the HTML for a single filterable list-group-item.
     * This now includes a checkbox.
     *
     * @param {object} group - A group object { icon, color, types }
     * @param {object} markerCounts - The object of marker counts.
     * @returns {string} HTML string for the legend item
     */
    function createFilterableLegendItemHTML(group, markerCounts) {
        const primaryName = group.types[0]
            .replace(/_/g, ' ')
            .replace(/\b\w/g, l => l.toUpperCase());

        const tooltipTitle = `Applies to: ${group.types.join(', ')}`;
        const otherTypesCount = group.types.length - 1;

        // We store all types this group represents in a data-attribute
        // on the checkbox for easy filtering later.
        const allTypes = group.types.join(',');

        // The unique ID for the checkbox and its label
        const checkId = `legend-check-${group.types[0]}`;

        // Calculate total count for this group
        let totalCount = 0;
        group.types.forEach(type => {
            // Add the count for each type in this group
            // Use (markerCounts[type] || 0) in case a type has 0 markers
            totalCount += (markerCounts[type] || 0);
        });

        // Not needed anymore
        //if (totalCount === 0) {
        //    return "";
        //}

        return `
            <li class="list-group-item py-1 px-2 small"
                data-bs-toggle="tooltip"
                data-bs-placement="right"
                data-bs-title="${tooltipTitle}">

                <div class="d-flex align-items-center">
                    <input class="form-check-input me-2 legend-item-check"
                           type="checkbox"
                           value="${group.types[0]}"
                           id="${checkId}"
                           data-types="${allTypes}"
                           checked>

                    <span class="fa-stack fa-1x me-2" aria-hidden="true">
                        <i class="fa-solid fa-circle fa-stack-2x" style="color: ${group.color};"></i>
                        <i class="fa-solid fa-${group.icon} fa-stack-1x fa-inverse"></i>
                    </span>

                    <div class="flex-grow-1 me-2">
                        <label class="form-check-label legend-text d-block" for="${checkId}">
                            ${primaryName}
                        </label>
                        <small class="text-muted"> ${totalCount} markers </small>
                    </div>

                    ${otherTypesCount > 0 ? `
                        <span class="badge bg-secondary rounded-pill ms-auto">
                            +${otherTypesCount}
                        </span>` : ''}
                </div>
            </li>
        `;
    }

    /**
     * Populates the legend in the DOM.
     * Call this function once in your $(document).ready().
     */
    function populateLegend(markerCounts) {
        // 1. Get the styles
        const groupedStyles = getGroupedStyles();

        // 2. Filter based on markerCounts
        const stylesToShow = groupedStyles.map(group => {
            // Calculate the total count for this group using markerCounts
            let totalCount = 0;
            group.types.forEach(type => {
                totalCount += (markerCounts[type] || 0);
            });

            // Add the count directly to the group object
            group.totalCount = totalCount;
            return group;
        }).filter(group => group.totalCount > 0);

        // 3. Sort by color (or icon, as you prefer)
        stylesToShow.sort((a, b) => {
            const colorCompare = a.color.localeCompare(b.color);
            if (colorCompare !== 0) return colorCompare;
            return a.icon.localeCompare(b.icon);
        });

        // 4. Get the *new* container
        const $legendList = $('#legend-list-items');
        $legendList.empty();

        // 5. Create and append the HTML
        stylesToShow.forEach(group => {
            const itemHtml = createFilterableLegendItemHTML(group, markerCounts);
            $legendList.append(itemHtml);
        });

        // 6. Initialize Bootstrap Tooltips
        const tooltipTriggerList = [].slice.call(
            document.querySelectorAll('[data-bs-toggle="tooltip"]')
        );
        tooltipTriggerList.map(function (tooltipTriggerEl) {
            return new bootstrap.Tooltip(tooltipTriggerEl);
        });

        // 7. Attach all event listeners
        $('#legend-search-input').on('keyup', filterLegend);       // search input
        $('#legend-select-all').on('change', toggleAllCheckboxes); // select all

        // Listen for changes on ANY legend item checkbox
        // We use event delegation on the parent list for efficiency
        $legendList.on('change', '.legend-item-check', handleFilterChange);

        // Stop dropdown from closing when clicking inside the search box
        $('#legend-search-input, #legend-select-all').on('click', function(e) {
            e.stopPropagation();
        });
    }

    /**
     * Filters the legend list based on the search input.
     */
    function filterLegend() {
        const filterText = $(this).val().toUpperCase();

        $('#legend-list-items li').each(function() {
            const $li = $(this);
            // Check against the label text OR the tooltip text
            const labelText = $li.find('.legend-text').text().toUpperCase();
            const tooltipText = $li.data('bs-title').toUpperCase();

            if (labelText.includes(filterText) || tooltipText.includes(filterText)) {
                $li.show();
            } else {
                $li.hide();
            }
        });
    }

    /**
     * Checks or unchecks all item checkboxes based on the "Select All" checkbox.
     */
    function toggleAllCheckboxes() {
        const isChecked = $(this).is(':checked');
        // Find all item checkboxes and set their 'checked' property
        $('.legend-item-check').prop('checked', isChecked);

        // After changing all, trigger ONE filter update
        handleFilterChange();
    }

    /**
     * Updates the "Select All" checkbox state based on item checkboxes.
     * e.g., if one item is unchecked, "Select All" becomes unchecked.
     */
    function updateSelectAllState() {
        const $itemCheckboxes = $('.legend-item-check');
        const allChecked = $itemCheckboxes.length === $itemCheckboxes.filter(':checked').length;

        // Set the 'Select All' checkbox state
        $('#legend-select-all').prop('checked', allChecked);
    }

    /**
     * Gathers all unique types from *checked* legend items.
     * @returns {Set<string>} A Set object containing all types to show.
     */
    function getSelectedTypes() {
        const selectedTypes = new Set();

        // Loop over only the :checked checkboxes
        $('.legend-item-check:checked').each(function() {
            const types = $(this).data('types').split(',');
            types.forEach(type => selectedTypes.add(type));
        });

        return selectedTypes;
    }

    /**
     * This is the main function that triggers your Leaflet map filter.
     * It's called whenever *any* checkbox changes.
     */
    function handleFilterChange() {
        // 1. First, update the "Select All" checkbox's state
        updateSelectAllState();

        // 2. Get a Set of all "types" that should be visible
        const visibleTypes = getSelectedTypes();

       // console.log(visibleTypes)

        // This is very fast and is the *intended* way to filter clusters.
        markers.clearLayers(); // Remove all markers (fast)

        const markersToShow = allMarkers.filter(marker => {
            console.log(marker)
            return visibleTypes.has(marker.options.location.type);
        })

        //console.log(markersToShow.length)
       // Add back only the filtered markers (this is also very fast)
       markers.addLayers(markersToShow);

        // 3. --- YOUR LEAFLET LOGIC GOES HERE ---
        // This is where you will filter your Leaflet markers.
        //
        // Example:
        //
        // console.log("Filtering map to only show:", visibleTypes);
        //
        // myLeafletLayerGroup.eachLayer(function(layer) {
        //     // Assuming you stored the marker's type in its options
        //     const markerType = layer.options.type;
        //
        //     if (visibleTypes.has(markerType)) {
        //         layer.addTo(map); // Show it
        //     } else {
        //         layer.remove(); // Hide it
        //     }
        // });
    }


    /**
     * Updates the information panel with post and marker counts.
     * @param {Array} data - The global data array.
     * @param {L.MarkerClusterGroup} markers - The populated cluster group.
     */
    function updateMapInfo(data, markers) {
      var n_posts = getShortcodeCount(data);
      var n_plotted_markers = markers.getLayers().length;

      // Include information
      //$('#info').html("Posts: {0} | Markers: {1}".format(n_posts, n_plotted_markers));
      $('#nposts').html(n_posts);
      $('#nmarkers').html(n_plotted_markers);
    }



    // -----------------------------------------------------
    // Marker plotting functions
    // -----------------------------------------------------
    /**
     * Filters locations for a single post based on rank and page number.
     * **This is the function to edit if you want to change filtering logic.**
     * @param {object} post - The post object from the main data array.
     * @returns {Array} An array of location objects to be plotted.
     */
    function filterLocations(post) {
      // Guard clause: If no locations, return an empty array.
      if (!Array.isArray(post.gemini_locations) || post.gemini_locations.length === 0) {
        return [];
      }

      // ---  Rank & Page Filtering ---
      // 1. Categorize all locations by rank.
      const lowRankLocations = [];  // rank <= 4
      const highRankLocations = []; // rank > 4
      const unrankedLocations = []; // No rank

      post.gemini_locations.forEach(loc => {
        const rank = loc.rank;
        if (typeof rank === 'number') {
          if (rank <= 4) {
            lowRankLocations.push(loc);
          } else {
            highRankLocations.push(loc);
          }
        } else {
          unrankedLocations.push(loc);
        }
      });

      // 2. Determine the preliminary list based on your rank rules.
      let preliminaryLocations = [];

      if (lowRankLocations.length > 0) {
        // Rule 1: Low ranks (<=4) exist. Use *all* of them.
        preliminaryLocations = lowRankLocations;

      } else if (highRankLocations.length > 0) {
        // Rule 2: No low ranks, but high ranks (>4) exist.
        // Find the *single lowest rank* from this group.
        const minHighRank = Math.min(...highRankLocations.map(loc => loc.rank));
        preliminaryLocations = highRankLocations.filter(loc => loc.rank === minHighRank);

      } else {
        // Rule 3: No ranks at all. Fall back to using all unranked locations.
        preliminaryLocations = unrankedLocations;
      }

      // 3. Apply the final 'post.num' filter to the preliminary list.  <== REVISIT!
      const locationsToPlot = post.sidecar_shortcode
        ? preliminaryLocations.filter(loc => loc.page === post.num)
        : preliminaryLocations;

      return locationsToPlot;
    }


    /**
    * Creates a single Leaflet marker for a location, with popup and click event.
    * @param {object} location - The location object.
    * @param {object} post - The parent post object.
    * @returns {L.Marker|null} A Leaflet marker object, or null if lat/lng is invalid.
    */
    function createMarker(location, post) {
      //console.log(location)
      // Get latitude and longitude
      const latitude = get(location, 'latitude', ATTR);
      const longitude = get(location, 'longitude', ATTR);

      // Guard clause for invalid lat/lng.
      if (!isFloat(latitude) || !isFloat(longitude)) {
        return null;
      }

      // Create a unique options object for this specific marker.
      const markerOptions = {
        ...post,                     // Copy base post properties
        icon: get_icon(5, location), // (assuming 'get_icon' is defined)
        page: location.page,          // Store the correct page number
        location: location
      };

      // Create marker
      const marker = L.marker([latitude, longitude], markerOptions);

      // Add popup
      marker.bindPopup(getPopupHTML(post, location));

      // On click
      marker.on('click', e => {
        const obj = e.target.options;
        // Message indicating the image page.
        const alertHtml = (obj.page > 1)
           ? `<div class="alert alert-warning" role="alert">
                 This pin corresponds to image <b>${obj.page}</b>.
               </div>`
           : '';
        // Create template with shortcode (assuming 'template_embed' is defined)
        let postHtml = alertHtml + template_embed.format(obj.shortcode);

        // Check if post_shortcode exists AND is different from shortcode
        if (obj.post_shortcode && obj.shortcode !== obj.post_shortcode) {
          // Append the second embed if they are different
          postHtml += template_embed.format(obj.post_shortcode);
        }

        $('#post-embed').html(postHtml);
        window.instgrm.Embeds.process();
      });

      return marker;
    }


    /**
     * Processes the entire data array, filters locations, and plots them.
     * @param {Array} data - The global data array.
     *POST* @param {L.MarkerClusterGroup} markers - The cluster group to add markers to.
     */
    function processDataAndPlot(data, markers) {
      console.log("Data:", data);

      allMarkers = []

      // Use native .forEach for the outer loop.
      data.forEach(post => {
        // Step 1: Get the filtered list of locations for this post.
        const locationsToPlot = filterLocations(post);
        // Step 2: Loop over the filtered list and create markers.
        locationsToPlot.forEach(location => {
          const marker = createMarker(location, post);
          // Add valid markers to the cluster group.
          if (marker) {
            allMarkers.push(marker);
            markers.addLayer(marker);
          }
        }); // End inner loop
      }); // End outer loop

      // 4. Add the Cluster Group to the Map
      map.addLayer(markers);
    }


    // A $( document ).ready() block.
    $(document).ready(function () {

      // 1. Process all data and plot the filtered markers
      processDataAndPlot(data, markers);
      // 2. Create the marker counts
      const markerCounts = countMarkersByType(allMarkers);
      // 2. Populate the legend based on the plotted data
      populateLegend(markerCounts);
      // 3. Populate the info panels with final counts
      updateMapInfo(data, markers);

      // Listen for the 'input' event on the slider
      // ('input' fires every time it moves, 'change' only fires on release)
      $('#cluster-radius-slider').on('input', function() {
          // 1. Get the new value from the slider
          const newRadius = parseInt($(this).val(), 10);

          // --- THIS IS THE NEW LINE ---
        // 2. Update the text in the badge
        $('#cluster-radius-value').text(newRadius);

          // 2. Update the option directly on the cluster group object
          markers.options.maxClusterRadius = newRadius;

          // 3. "Refresh" the cluster group using our global 'allMarkers' array
          // This is the essential part. It's very fast.
          markers.clearLayers();
          markers.addLayers(allMarkers);
      });

     setupKmlExportListener()

    });



    /*
    // Examples to get data.
    import data from './data.json';
    console.log(data)

    function grabData() {
    return fetch("./data/_summary.json")
      .then(response => response.json());
    }

    grabData().then(data => console.log(data));
    const sample = require('./data/_summary.json');
    console.log(sample)

    fetch('./data/_summary.json')
      .then(response => response.json())
      .then(data => console.log(data))
      .catch(error => console.log(error));
    */



  /*

  <button aria-label="Siguiente" class=" _afxw _al46 _al47" tabindex="-1"><div class=" _9zm2"></div></button>

   */

</script>
</html>
